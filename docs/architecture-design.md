# DEFCHR TOOL for Web - アーキテクチャ設計書

> **Version**: 1.0.0
> **作成日**: 2026-02-01
> **作成者**: 設計検討チーム（足軽5〜8号）統合版

---

## 1. 概要

### 1.1 プロジェクトの目的

DEFCHR TOOL for Web は、1980年代の SHARP X1 パソコン用 PCG（Programmable Character Generator）エディタ「DEFCHR TOOL」を Web ブラウザ上で再現するプロジェクトである。

**主な目的：**
- X1 PCGエディタの操作感をWeb上で再現
- 8x8ドット、8色（RGB 3プレーン）のPCGキャラクター編集
- 256文字の定義・管理
- X1互換フォントによるレトロ風UIの実現

### 1.2 技術的制約のまとめ

| 制約項目 | 詳細 |
|---------|------|
| **解像度** | WIDTH 40: 320x200 / WIDTH 80: 640x200 |
| **色数** | 8色（R, G, B の3ビットプレーン） |
| **文字数** | 256文字（コード 0〜255） |
| **1文字サイズ** | 8x8ドット |
| **データサイズ** | 1文字: 24バイト / 全体: 6,144バイト |
| **ピクセルアスペクト** | WIDTH 40: 1:1 / WIDTH 80: 1:2（縦長） |
| **入力方式** | キーボード操作が主体（0-7キー、M/E/S/R/T/Pキー） |

---

## 2. 描画アーキテクチャ

### 2.1 選択肢の詳細説明

#### Canvas 2D API
Canvasの2Dコンテキストを使用したラスター描画。ImageDataによるピクセル操作が可能で、今回のようなピクセルベースの描画に最適。

#### WebGL
GPU直接アクセスによる3D/2D描画API。シェーダーを使用した高度なエフェクトが可能だが、実装が複雑。

#### OffscreenCanvas
Web Worker内で描画可能なCanvas。メインスレッドをブロックせずにバックグラウンド描画が可能。

#### SVG
XMLベースのベクターグラフィックス。解像度非依存だが、ピクセルベースの描画には不向き。

### 2.2 メリット・デメリット比較表

| 技術 | メリット | デメリット | 推奨度 |
|------|----------|------------|:------:|
| **Canvas 2D** | シンプルなAPI、ImageDataでピクセル操作容易、広いブラウザサポート、drawImage()で高速転送 | 大量オブジェクト描画時はWebGLより遅い（今回は該当せず） | ★★★★★ |
| **WebGL** | GPU活用で高速、シェーダーで柔軟なエフェクト | 複雑なAPI、ピクセル操作が面倒、オーバースペック、デバッグ困難 | ★★☆☆☆ |
| **OffscreenCanvas** | Worker内描画可能、バックバッファとして有効 | Safari対応が最近、通信オーバーヘッド、コード複雑化 | ★★★☆☆ |
| **SVG** | 解像度非依存、DOM操作が直感的 | ピクセルベース描画に不向き、大量要素で非効率、レトロ表現に不適 | ★☆☆☆☆ |

### 2.3 推奨案と理由

**推奨: Canvas 2D + ダブルバッファリング方式**

| 推奨理由 |
|----------|
| 1. **シンプルさ**: Canvas 2D APIは直感的で保守性が高い |
| 2. **ピクセル操作**: ImageDataによるピクセル操作がPCG描画に最適 |
| 3. **パフォーマンス**: 320x200の描画は現代ブラウザで十分高速 |
| 4. **ブラウザサポート**: 広いサポートで互換性問題なし |
| 5. **仕様書準拠**: オフスクリーン描画方式の推奨に合致 |

### 2.4 アーキテクチャ構成

```
┌─────────────────────────────────────────┐
│         表示用Canvas（フロントバッファ）      │
│         サイズ: CSS/表示サイズ依存          │
│         └─ drawImage()で転送             │
└─────────────────────────────────────────┘
                    ↑
┌─────────────────────────────────────────┐
│      バックバッファ（オフスクリーンCanvas）   │
│      サイズ: 640x200（最大解像度で固定）    │
│      └─ X1フォント描画                   │
│      └─ 編集エリア描画                   │
│      └─ 256文字定義エリア描画            │
│      └─ カーソル・メニュー描画            │
└─────────────────────────────────────────┘
```

### 2.5 WIDTH切り替え対応

| モード | ソース領域 | 表示サイズ | ピクセルアスペクト |
|--------|-----------|-----------|------------------|
| WIDTH 40 | 320x200（バックバッファ左半分） | 640x400推奨（2倍） | 1:1（正方形） |
| WIDTH 80 | 640x200（バックバッファ全体） | 640x400推奨 | 1:2（縦長） |

### 2.6 実装上の注意点

- `imageSmoothingEnabled = false` でピクセルパーフェクト表示
- `requestAnimationFrame` による描画ループ
- 部分更新用のdirtyフラグ管理で効率化
- X1フォントはImageData配列として事前読み込み
- 8色パレットは定数として定義（R,G,Bの組み合わせ）
- 高DPIディスプレイでは `devicePixelRatio` を考慮

### 2.7 パフォーマンス見積もり

| 項目 | 値 | 備考 |
|------|-----|------|
| FPS目標 | 60fps | 問題なく達成可能 |
| 描画面積 | 128,000px | 640x200、現代GPUでは極めて軽量 |
| バックバッファ | 512KB | 640 x 200 x 4 bytes |
| フロントバッファ | 約2MB | 表示サイズ依存（例: 1280x400） |
| フォントアトラス | 64KB | 256文字 x 8x8 x 4 bytes |
| **合計メモリ** | **約3-5MB** | 現代ブラウザでは問題なし |

---

## 3. フレームワーク選定

### 3.1 プロジェクト特性の整理

本プロジェクトは以下の特性を持つ：

- Canvasベースの描画が中心（8x8ドット編集、オフスクリーン描画）
- 256文字 × 3プレーン(RGB) のPCGデータ管理
- キーボード入力が主体の操作体系
- X1互換フォントを使ったレトロ風UI
- **DOM操作は最小限**（Canvas描画がメイン）

### 3.2 選択肢の詳細説明

#### Vanilla JS
フレームワークなしの素のJavaScript。依存関係がなく、Canvas操作が直接的。

#### React
Meta社が開発した人気のUIライブラリ。仮想DOMとコンポーネント指向が特徴。

#### Vue
学習曲線が緩やかなリアクティブフレームワーク。Single File Componentで整理しやすい。

#### Svelte
コンパイル時に最適化し、ランタイムなしで動作する軽量フレームワーク。

### 3.3 メリット・デメリット比較表

| フレームワーク | メリット | デメリット | バンドルサイズ | 推奨度 |
|--------------|----------|------------|--------------|:------:|
| **Vanilla JS** | 依存なし・最軽量、Canvasと直接連携、長期保守に最適 | 状態管理を自前実装、大規模化時の保守性課題 | 0KB | ★★★★☆ |
| **React** | 最大コミュニティ、構造化しやすい、多くのエンジニアが習熟 | 仮想DOMメリット薄い、オーバースペック、破壊的変更リスク | 約40KB | ★★☆☆☆ |
| **Vue** | 学習曲線緩やか、リアクティブ使いやすい | Canvasアプリに不向き、オーバースペック | 約30KB | ★★☆☆☆ |
| **Svelte** | 軽量出力、リアクティブ構文シンプル | コミュニティ小さい、Canvasとの統合は手動 | 約5KB | ★★★☆☆ |

### 3.4 推奨案と理由

**推奨: Vanilla JS + Vite**

| 推奨理由 |
|----------|
| 1. Canvas操作が主体のため、フレームワークのDOM抽象化メリットがほぼ無い |
| 2. 256文字のPCGデータは単純なクラス/オブジェクトで十分管理可能 |
| 3. 依存関係がないため、5年後・10年後も動作する可能性が高い |
| 4. Viteでモダンな開発体験（HMR、ESモジュール）を維持 |
| 5. バンドルサイズ最小化によりロード時間短縮 |

### 3.5 状態管理の推奨

**推奨: クラスベースの状態管理**

```typescript
// PCGデータ管理
class PCGStore {
  characters[256]: PCGCharacter;  // 各キャラクターのR/G/Bプレーン
  getCharacter(code: number): PCGCharacter;
  setCharacter(code: number, data: PCGCharacter): void;
}

// 編集状態管理
class EditorState {
  currentMode: EditMode;      // 編集モード
  cursorPosition: Position;   // カーソル位置
  currentColor: number;       // 選択中の色（0-7）
  direction: Direction;       // 最後の移動方向
}

// EventEmitterパターンで状態変更を通知
```

### 3.6 ビルドツールの推奨

**推奨: Vite**

| Vite選定理由 |
|-------------|
| 高速なHMR（Hot Module Replacement） |
| ESモジュールのネイティブサポート |
| 最小限の設定で使用可能 |
| ビルド時にRollupで最適化 |
| TypeScript対応も容易 |

### 3.7 追加推奨事項

| 項目 | 推奨 | 理由 |
|------|------|------|
| 型システム | TypeScript | 型安全性、IDE支援向上 |
| コード品質 | ESLint + Prettier | 一貫したコーディングスタイル |
| テスト | Vitest | Viteとの親和性、高速実行 |

---

## 4. データ構造設計

### 4.1 PCGデータの内部表現

#### PCGデータの構造

```
1文字のPCGデータ構成:
- B（青）プレーン: 8バイト（8行×1バイト/行）
- R（赤）プレーン: 8バイト
- G（緑）プレーン: 8バイト
- 合計: 24バイト/文字

全PCGデータ:
- 256文字 × 24バイト = 6,144バイト
```

#### 内部表現の選択肢

| 方式 | 説明 | メリット | デメリット | 推奨度 |
|------|------|----------|------------|:------:|
| **TypedArray方式** | Uint8Arrayで管理 | メモリ効率最高、バイナリ親和性、ビット演算高速、SharedArrayBuffer対応 | ドット単位アクセスにビット演算必要、デバッグ時の可読性低い | ★★★★★ |
| **2次元配列方式** | number[][]で管理 | 直感的アクセス、デバッグ容易 | メモリ使用量大、バイナリ変換必要 | ★★☆☆☆ |
| **ラッパークラス方式** | Uint8Array + API | 効率と利便性両立 | クラス実装の手間、メソッドオーバーヘッド | ★★★★☆ |

#### 推奨: TypedArray方式（Uint8Array）

```typescript
// 1文字分のPCGデータ（24バイト = B,R,G各8バイト）
interface PCGCharacter {
  readonly data: Uint8Array;  // 24バイト固定
  getPixel(x: number, y: number): number;  // 0-7
  setPixel(x: number, y: number, color: number): void;
}

// 全PCGデータ（256文字）
interface PCGData {
  readonly buffer: ArrayBuffer;  // 6144バイト
  readonly characters: Uint8Array;  // view into buffer
  getCharacter(code: number): PCGCharacter;
  copyToCanvas(ctx: CanvasRenderingContext2D, code: number, x: number, y: number): void;
}
```

| TypedArray推奨理由 |
|-------------------|
| 1. X1のPCGはビットプレーン形式であり、TypedArrayがネイティブ表現 |
| 2. ファイル入出力（BASIC形式/バイナリ形式）との変換が最小限 |
| 3. 8x8×256文字の描画パフォーマンスが重要 |
| 4. 将来的にOffscreenCanvas + Web Workerで並列描画する場合に有利 |

### 4.2 ROMフォントデータ管理方法

| 方式 | 説明 | メリット | デメリット | 推奨度 |
|------|------|----------|------------|:------:|
| **fetch + ArrayBuffer** | 初期化時にfetchでバイナリロード | シンプル、メモリ効率良い | 初期ロード待ちが必要 | ★★★★☆ |
| **Base64埋め込み** | JSファイルに埋め込み | ネットワークリクエスト不要 | JSファイルサイズ増加（約2.7KB） | ★★★☆☆ |
| **IndexedDBキャッシュ** | 初回fetchでIndexedDBに保存 | 2回目以降高速、オフライン対応 | 実装複雑 | ★★☆☆☆ |

**推奨: fetch + ArrayBuffer方式**

| 推奨理由 |
|---------|
| 2KBのフォントデータはロード時間が無視できるほど小さい |
| 実装がシンプルで保守性が高い |
| Service Workerで後からキャッシュ対応可能 |

### 4.3 Undo/Redo対応の設計

| 方式 | 説明 | メリット | デメリット | 推奨度 |
|------|------|----------|------------|:------:|
| **Commandパターン** | 各操作をCommandオブジェクトとして記録 | きめ細かくUndo可能、Redoも自然に実装 | 操作ごとにCommandクラスが必要 | ★★★★☆ |
| **Immutableスナップショット** | 操作ごとに全体をコピー | 実装がシンプル、状態復元が確実 | メモリ使用量大（6KB×履歴数） | ★★☆☆☆ |
| **差分記録方式** | 変更されたピクセルのみ記録 | メモリ効率が非常に高い | 複合操作の差分が大きい、復元ロジック複雑 | ★★★☆☆ |
| **ハイブリッド方式** | 小変更は差分、大変更はスナップショット | メモリ効率と実装のバランス | 閾値の調整が必要 | ★★★★★ |

**推奨: Commandパターン + 差分記録ハイブリッド**

```typescript
interface Command {
  execute(): void;
  undo(): void;
  redo(): void;
  getDescription(): string;
}

// ドット編集（差分記録：数バイト/操作）
class SetPixelCommand implements Command {
  constructor(
    private pcg: PCGData,
    private charCode: number,
    private x: number,
    private y: number,
    private newColor: number,
    private oldColor: number
  ) {}
}

// 回転・反転（スナップショット：64-256バイト）
class RotateCommand implements Command {
  constructor(
    private pcg: PCGData,
    private charCode: number,
    private snapshot: Uint8Array  // 24バイト
  ) {}
}

class UndoManager {
  private history: Command[] = [];
  private position: number = -1;
  private maxHistory: number = 100;  // 履歴上限
}
```

### 4.4 ファイル入出力形式

| 形式 | 説明 | インポート難度 | エクスポート難度 | 用途 |
|------|------|:-------------:|:---------------:|------|
| **BASIC形式（DEFCHR$）** | X1 BASICのDEFCHR$文テキスト | 中 | 低 | X1エミュレータ実行 |
| **バイナリ形式（通常定義）** | PCGデータをそのままバイナリ保存 | 低 | 低 | データ保存、他ツール連携 |
| **3倍速定義バイナリ** | プレーンごとにまとめて格納 | 低 | 低 | X1での高速ロード |
| **PCG形式（x1pcgconv互換）** | ヘッダ + PCGデータ | 中 | 中 | x1pcgconvとの連携 |
| **JSON形式（Web独自）** | メタデータ含むJSON | 低 | 低 | Web版での保存・共有 |

#### BASIC形式の構造
```basic
60960 DEFCHR$(96)=HEXCHR$("FF80909090909080FF80808080808080FF80808080808080")
```
※ HEXCHR$内は B(8バイト) + R(8バイト) + G(8バイト) = 48文字hex

#### JSON形式の構造
```json
{
  "version": "1.0",
  "name": "my_pcg_set",
  "created": "2026-02-01T...",
  "modified": "2026-02-01T...",
  "data": "base64..."
}
```

#### 実装優先順位

| 優先度 | 形式 | 理由 |
|:------:|------|------|
| 1 | バイナリ形式（通常定義） | 最も単純、デバッグに有用 |
| 2 | JSON形式（Web独自） | メタデータ保存、ブラウザ保存に最適 |
| 3 | BASIC形式（DEFCHR$） | オリジナルツールとの互換性 |
| 4 | 3倍速定義バイナリ | X1実機/エミュレータ連携 |
| 5 | PCG形式 | x1pcgconvの詳細仕様確認後 |

---

## 5. UI/UX設計

### 5.1 X1互換フォントでのUI構築方法

**推奨: Canvas描画UI（2D Context）**

| 方式 | メリット | デメリット | 推奨度 |
|------|----------|------------|:------:|
| **Canvas描画UI** | ピクセルパーフェクト再現、WIDTH切替容易、CRT効果実装容易、仕様書推奨に合致 | アクセシビリティ困難、テキスト選択不可 | ★★★★★ |
| **DOM + CSS UI** | 実装シンプル、CSSフィルタ可能 | ピクセルパーフェクト困難、WIDTH切替複雑、多数DOM要素でパフォーマンス懸念 | ★★☆☆☆ |
| **WebGL描画UI** | 最高パフォーマンス、高度なCRTシェーダー | 実装コスト高、オーバースペック、デバッグ困難 | ★★★☆☆ |

#### Canvas描画UIの実装方針

```
メインキャンバス: 320x200 または 640x200（論理解像度）
表示キャンバス: CSS transformでスケールアップ（2〜3倍推奨）
スタイル: image-rendering: pixelated でドット感維持
バッファリング: OffscreenCanvas使用でダブルバッファリング
```

### 5.2 キーボード操作マッピング

#### コアマッピング

| X1キー | Webキー | 機能 |
|--------|---------|------|
| カーソルキー | ArrowUp/Down/Left/Right | カーソル移動 |
| 0-7 | Digit0-7 / Numpad0-7 | 色選択・ドット描画 |
| M | KeyM | EDIT MODE |
| E | KeyE | EDIT CHR. |
| S | KeyS | SET CHR. |
| R | KeyR | ROTATION |
| T | KeyT | TRANSFER |
| P | KeyP | PROGRAMMING |

#### Web版拡張機能

| キー | 機能 |
|------|------|
| Ctrl+Z | Undo |
| Ctrl+Y / Ctrl+Shift+Z | Redo |
| Ctrl+S | 保存ダイアログ |
| Ctrl+O | 開くダイアログ |
| Escape | メニューキャンセル/マウスモード解除 |

#### 実装上の注意

| 注意事項 |
|----------|
| `keydown`イベントで`e.preventDefault()`必須（ブラウザ標準動作防止） |
| `KeyboardEvent.code`を使用（言語非依存、物理キー位置取得） |
| IME入力中（`isComposing`）は無視 |
| フォーカスがinput要素にある時はショートカット無効化 |

### 5.3 マウスモード実装方法

**UI配置**: Canvas外の上部または右側にトグルボタン配置

#### モード別の動作

| 動作 | キーボードモード | マウスモード |
|------|-----------------|--------------|
| 0-7キー | 色選択 + 即座に描画 | 色選択のみ（描画しない） |
| カーソルキー | カーソル移動 | - |
| 左クリック | - | 選択色でドット描画 |
| ドラッグ | - | 連続描画（フリーハンド） |
| 右クリック | - | 消去（色0で描画） |

#### 座標変換の手順

```
1. MouseEvent.offsetX/Y でキャンバス相対座標取得
2. CSS scale考慮してCanvas論理座標に変換
3. 論理座標を8で割って編集エリア内のドット位置計算
4. 編集エリア境界チェック
```

#### 将来の拡張候補

| 操作 | 機能 |
|------|------|
| Shift+ドラッグ | 直線描画 |
| Ctrl+ドラッグ | 矩形範囲選択 |
| 右ドラッグ | 連続消去 |

### 5.4 CRT風表示オプション

**推奨**: 軽量版（CSS）をデフォルト、重厚版（Canvas overlay）をオプション

#### 軽量版（CSS）

| エフェクト | 実装方法 |
|-----------|----------|
| スキャンライン | `::after`疑似要素で`repeating-linear-gradient` |
| グロー/ブラー | `filter: brightness(1.1) contrast(1.1)` |
| 湾曲効果 | `border-radius + box-shadow`（軽微な湾曲感） |

```css
/* スキャンライン例 */
.crt::after {
  background: repeating-linear-gradient(
    transparent 0 2px,
    rgba(0,0,0,0.3) 2px 4px
  );
}
```

#### 重厚版（Canvas overlay）

| エフェクト | 実装方法 |
|-----------|----------|
| スキャンライン | オーバーレイキャンバスに水平線描画 |
| RGBにじみ | 3回描画でRGB分離 |
| ビネット | 円形グラデーションで周辺減光 |

### 5.5 レスポンシブ対応

**推奨: デスクトップ専用**

| 項目 | 内容 |
|------|------|
| モバイル対応 | **非対応**（表示のみの閲覧モードは可能） |
| 理由 | ターゲットユーザーはレトロPC愛好家、キーボード操作必須、精密な8x8編集に画面サイズ必要 |
| 最小解像度 | 800x600（1024x768推奨） |
| 表示スケール | 2〜3倍（320x200 → 640x400〜960x600） |

#### モバイル時の対応

```
画面幅768px未満で「デスクトップでの閲覧を推奨」メッセージ表示
タッチ操作での簡易閲覧は許可（ズーム、スクロール）
編集機能はデスクトップのみに制限
```

---

## 6. 推奨構成まとめ

### 6.1 最終的な推奨技術スタック

| カテゴリ | 推奨技術 | 理由 |
|---------|----------|------|
| **描画** | Canvas 2D + ダブルバッファリング | シンプル、ピクセル操作に最適、仕様書推奨に合致 |
| **フレームワーク** | Vanilla JS | DOM操作最小限のためFW不要、長期保守に有利 |
| **ビルドツール** | Vite | 高速HMR、最小設定、TypeScript対応 |
| **言語** | TypeScript | 型安全性、IDE支援 |
| **データ構造** | Uint8Array | メモリ効率、バイナリ親和性、X1ネイティブ表現 |
| **状態管理** | クラス + EventEmitter | シンプルで十分 |
| **Undo/Redo** | Commandパターン + 差分記録 | メモリ効率と実装のバランス |
| **UI描画** | Canvas（X1フォント） | ピクセルパーフェクト再現 |
| **CRT効果** | CSS（軽量）/ Canvas overlay（オプション） | パフォーマンスと再現性のバランス |

### 6.2 リスクと懸念事項

| リスク | 深刻度 | 対策 |
|--------|:------:|------|
| ブラウザ間のCanvas描画差異 | 低 | 標準APIのみ使用 |
| 高DPIディスプレイでのぼやけ | 中 | `devicePixelRatio`を考慮したCanvas解像度設定 |
| Safari/iOSのCanvas制限 | 低 | バッファサイズを制限内に収める |
| WIDTH 80の縦長ピクセル表現 | 中 | CSS aspect-ratioまたは明示的スケーリング |
| X1font.pngの読み込み遅延 | 低 | preloadで先読み、ローディング表示 |
| キーボードイベントのブラウザ差異 | 中 | `KeyboardEvent.code`で統一、主要ブラウザでテスト |
| Canvas描画パフォーマンス | 低 | `requestAnimationFrame`、変更箇所のみ再描画 |
| 大量Undo時のメモリ消費 | 低 | 履歴上限（100回）と定期スナップショット圧縮 |
| PCG形式の詳細仕様が不明 | 中 | x1pcgconvのソースコード解析、または作者への問い合わせ |
| X1互換フォントのライセンス表記 | 低 | Misakiフォントのライセンスに従い使用許諾を明記 |

### 6.3 今後の検討課題

| 課題 | 内容 | 優先度 |
|------|------|:------:|
| フォント読み込みユーティリティ | fetch → スプライトシート化の共通処理 | 高 |
| 基本描画エンジン | 8x8文字描画の共通コンポーネント化 | 高 |
| CRT効果のプラグイン化 | 後から追加可能な設計 | 中 |
| Service Worker対応 | オフライン対応、PWA化 | 低 |
| x1pcgconv互換フォーマット | 詳細仕様の確認と実装 | 中 |
| 3倍速定義のフォーマット検証 | `-n`オプション有無の出力比較 | 低 |

---

## 付録: 参考情報

### PCGのビットプレーン構造

```
1ドットの色値 (0-7) は RGB 3ビットで構成:
  bit 0: B (青)
  bit 1: R (赤)
  bit 2: G (緑)

例: 色7 (白) = B:1, R:1, G:1
    色4 (緑) = B:0, R:0, G:1
```

### X1の8色パレット

| 色番号 | 色名 | RGB |
|:------:|------|-----|
| 0 | 黒 | (0, 0, 0) |
| 1 | 青 | (0, 0, 255) |
| 2 | 赤 | (255, 0, 0) |
| 3 | マゼンタ | (255, 0, 255) |
| 4 | 緑 | (0, 255, 0) |
| 5 | シアン | (0, 255, 255) |
| 6 | 黄 | (255, 255, 0) |
| 7 | 白 | (255, 255, 255) |

---

*本設計書は足軽5号（描画アーキテクチャ）、足軽6号（フレームワーク選定）、足軽7号（データ構造設計）、足軽8号（UI/UX設計）の報告書を統合し、テクニカルライター/シニアアーキテクトの視点で整理・構造化したものである。*
